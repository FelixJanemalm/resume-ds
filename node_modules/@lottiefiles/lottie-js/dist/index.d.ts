declare abstract class Asset {
    abstract fromJSON(json: Record<string, any>): Asset;
    abstract toJSON(): Record<string, any>;
    parent: any;
    constructor(parent: any);
}

declare class ImageAsset extends Asset {
    data?: string;
    id?: string;
    height: number;
    path?: string;
    width: number;
    fromJSON(json: Record<string, any>): ImageAsset;
    toJSON(): Record<string, any>;
}

declare enum AssetType {
    PRECOMPOSITION = 0,
    IMAGE = 1
}

declare enum BlendMode {
    NORMAL = 0,
    MULTIPLY = 1,
    SCREEN = 2,
    OVERLAY = 3,
    DARKEN = 4,
    LIGHTEN = 5,
    COLOR_DODGE = 6,
    COLOR_BURN = 7,
    HARD_LIGHT = 8,
    SOFT_LIGHT = 9,
    DIFFERENCE = 10,
    EXCLUSION = 11,
    HUE = 12,
    SATURATION = 13,
    COLOR = 14,
    LUMINOSITY = 15
}

declare enum FillRuleType {
    EVEN_ODD = 1,
    NONZERO = 2
}

declare enum GradientFillType {
    NONE = 0,
    LINEAR = 1,
    RADIAL = 2,
    ANGULAR = 4,
    REFLECTED = 5,
    DIAMOND = 6
}

declare enum GradientStrokeType {
    LINEAR = 1,
    RADIAL = 2
}

declare enum LayerType {
    PRECOMPOSITION = 0,
    SOLID = 1,
    IMAGE = 2,
    GROUP = 3,
    SHAPE = 4,
    TEXT = 5,
    AUDIO = 6,
    VIDEO_PLACEHOLDER = 7,
    IMAGE_SEQUENCE = 8,
    VIDEO = 9,
    IMAGE_PLACEHOLDER = 10,
    GUIDE = 11,
    ADJUSTMENT = 12,
    CAMERA = 13,
    LIGHT = 14
}

declare enum LineCapType {
    BUTT = 1,
    ROUND = 2,
    PROJECTING = 3
}

declare enum LineJoinType {
    MITER = 1,
    ROUND = 2,
    BEVEL = 3
}

declare enum MaskMode {
    None = "n",
    Add = "a",
    Subtract = "s",
    Intersect = "i",
    Lighten = "l",
    Darken = "d",
    Difference = "f"
}

declare enum PropertyType {
    ANCHOR = "a",
    OPACITY = "o",
    POSITION = "p",
    ROTATION = "r",
    ROTATION_X = "rx",
    ROTATION_Y = "ry",
    ROTATION_Z = "rz",
    SCALE = "s",
    SKEW_AXIS = "sa",
    SKEW = "sk",
    SHAPE = "sh",
    EXPANSION = "x",
    FEATHER = "f",
    SIZE = "sz",
    ROUNDNESS = "rd",
    MITER_LIMIT = "ml",
    STROKE_WIDTH = "sw",
    NUMBER = "nu",
    COLOR = "cl",
    ORIENTATION = "or"
}

declare enum ShapeType {
    ELLIPSE = "el",
    FILL = "fl",
    GRADIENT_FILL = "gf",
    GRADIENT_STROKE = "gs",
    GROUP = "gr",
    MERGE = "mm",
    OFFSET_PATH = "op",
    PATH = "sh",
    RECTANGLE = "rc",
    REPEATER = "rp",
    ROUNDED_CORNERS = "rd",
    STAR = "sr",
    STROKE = "st",
    TRIM = "tm",
    TWIST = "tw"
}

declare enum TrimMode {
    SIMULTANEOUSLY = 1,
    INDIVIDUALLY = 2
}

declare enum RepeaterComposite {
    ABOVE = 1,
    BELOW = 2
}

declare enum StarType {
    STAR = 1,
    POLYGON = 2
}

declare class KeyFrame {
    frame: number;
    value: number | number[];
    frameInTangent?: [number, number];
    frameOutTangent?: [number, number];
    valueInTangent?: [number, number];
    valueOutTangent?: [number, number];
    hold: boolean;
    constructor(frame?: number, value?: number | number[]);
    fromJSON(json: Record<string, any>): KeyFrame;
    toJSON(): Record<string, any>;
}

declare class Property {
    UID: number;
    readonly type: PropertyType;
    expression?: string;
    isAnimated: boolean;
    index: number;
    maxColors?: number;
    values: Array<KeyFrame>;
    private _parent;
    getParent(): any;
    constructor(parent: any, type: PropertyType, values?: Array<KeyFrame>);
    fromJSON(json: Record<string, any>): Property;
    toJSON(): Record<string, any>;
}

declare abstract class Layer {
    abstract readonly type: LayerType;
    abstract fromJSON(json: Record<string, any>): Layer;
    abstract toJSON(key?: string): Record<string, any> | undefined;
    autoOrient: boolean;
    blendMode: BlendMode;
    classNames: string[];
    effects: any;
    height: number;
    id: string;
    index?: number;
    inPoint: number;
    is3D: boolean;
    name: string;
    outPoint: number;
    startTime: number;
    timeStretch: number;
    width: number;
    opacity: Property;
    position: Property;
    anchor: Property;
    scale: Property;
    orientation?: Property;
    rotation?: Property;
    rotationX?: Property;
    rotationY?: Property;
    rotationZ?: Property;
    protected parent: any;
    constructor(parent: any);
    get colors(): string[];
    get totalFrames(): number;
}

declare class GroupLayer extends Layer {
    readonly type = LayerType.GROUP;
    fromJSON(json: Record<string, any>): GroupLayer;
    toJSON(): Record<string, any>;
}

declare class ImageLayer extends Layer {
    readonly type = LayerType.IMAGE;
    refId: string;
    fromJSON(json: Record<string, any>): ImageLayer;
    toJSON(): Record<string, any>;
}

declare class PrecompositionLayer extends Layer {
    readonly type = LayerType.PRECOMPOSITION;
    refId?: string;
    timeRemap: any;
    fromJSON(json: Record<string, any>): PrecompositionLayer;
    toJSON(): Record<string, any>;
}

declare class GradientStop {
    offset: number;
    color: number[];
    constructor(offset?: number, color?: number[]);
    get hasAlpha(): boolean;
    get red(): number;
    get green(): number;
    get blue(): number;
    get alpha(): number | undefined;
}
declare class GradientColorsProperty extends Property {
    colorCount: number;
    private keyframeValue;
    keyframeHasAlpha(index: number): boolean;
    keframeStops(index: number): GradientStop[];
    setKeyframeStops(index: number, stops: GradientStop[]): void;
    addKeyframe(frame: number, stops: GradientStop[]): KeyFrame;
    private stopsToArray;
}
declare class Gradient {
    gradientColors: GradientColorsProperty;
    get colorCount(): number;
    set colorCount(count: number);
    toJSON(): Record<string, any>;
    fromJSON(json: Record<string, any>): Gradient;
}

declare abstract class Shape {
    abstract readonly type: ShapeType;
    abstract fromJSON(json: Record<string, any>): Shape;
    abstract toJSON(): Record<string, any>;
    classNames?: string;
    matchName?: string;
    name?: string;
    id?: string;
    itemIndex?: number;
    shapeIndex?: number;
    isHidden: boolean;
    parent: any;
    constructor(parent: any);
}

declare class EllipseShape extends Shape {
    readonly type = ShapeType.ELLIPSE;
    position: Property;
    size: Property;
    direction: number;
    fromJSON(json: Record<string, any>): EllipseShape;
    toJSON(): Record<string, any>;
}

declare class FillShape extends Shape {
    readonly type = ShapeType.FILL;
    blendMode: BlendMode;
    direction?: number;
    color: Property;
    fillRule: FillRuleType;
    opacity: Property;
    fromJSON(json: Record<string, any>): FillShape;
    toJSON(): Record<string, any>;
}

declare class GradientFillShape extends Shape {
    readonly type = ShapeType.GRADIENT_FILL;
    blendMode: BlendMode;
    endPoint: Property;
    gradientColors: Gradient;
    gradientType: GradientFillType;
    highlightAngle: Property;
    highlightLength: Property;
    opacity: Property;
    startPoint: Property;
    fillRule: FillRuleType;
    fromJSON(json: Record<string, any>): GradientFillShape;
    toJSON(): Record<string, any>;
}

declare class GroupShape extends Shape {
    readonly type = ShapeType.GROUP;
    anchor: Property;
    blendMode: BlendMode;
    contentPropertyIndex?: number;
    isHidden: boolean;
    numProperties: number;
    opacity: Property;
    position: Property;
    propertyIndex?: number;
    rotation: Property;
    scale: Property;
    shapes: Shape[];
    skew: Property;
    skewAxis: Property;
    fromJSON(json: Record<string, any>): GroupShape;
    createShape(type: ShapeType): Shape;
    toJSON(): Record<string, any>;
}

declare class PathShape extends Shape {
    readonly type = ShapeType.PATH;
    direction?: number;
    vertices: Property;
    fromJSON(json: Record<string, any>): PathShape;
    toJSON(): Record<string, any>;
}

declare class RectangleShape extends Shape {
    readonly type = ShapeType.RECTANGLE;
    direction?: number;
    position: Property;
    roundness: Property;
    size: Property;
    fromJSON(json: Record<string, any>): RectangleShape;
    toJSON(): Record<string, any>;
}

declare class StrokeShape extends Shape {
    readonly type = ShapeType.STROKE;
    blendMode: BlendMode;
    color: Property;
    lineCapType: LineCapType;
    lineJoinType: LineJoinType;
    miterLimit: number;
    opacity: Property;
    width: Property;
    fromJSON(json: Record<string, any>): StrokeShape;
    toJSON(): Record<string, any>;
}

declare class TrimShape extends Shape {
    readonly type = ShapeType.TRIM;
    blendMode: BlendMode;
    trimEnd: Property;
    trimOffset: Property;
    trimStart: Property;
    trimMultipleShapes: TrimMode;
    fromJSON(json: Record<string, any>): TrimShape;
    toJSON(): Record<string, any>;
}

declare class GradientStrokeShape extends Shape {
    readonly type = ShapeType.GRADIENT_STROKE;
    blendMode: BlendMode;
    endPoint: Property;
    gradientColors: Gradient;
    gradientType: GradientFillType;
    highlightAngle: Property;
    highlightLength: Property;
    opacity: Property;
    startPoint: Property;
    lineCapType: LineCapType;
    lineJoinType: LineJoinType;
    miterLimit: number;
    width: Property;
    fromJSON(json: Record<string, any>): GradientStrokeShape;
    toJSON(): Record<string, any>;
}

declare class RepeaterShape extends Shape {
    readonly type = ShapeType.REPEATER;
    anchor: Property;
    startOpacity: Property;
    endOpacity: Property;
    position: Property;
    rotation: Property;
    scale: Property;
    shapes: Shape[];
    skew: Property;
    skewAxis: Property;
    copies: Property;
    offset: Property;
    composition: RepeaterComposite;
    fromJSON(json: Record<string, any>): RepeaterShape;
    toJSON(): Record<string, any>;
}

declare class StarShape extends Shape {
    readonly type = ShapeType.STAR;
    position: Property;
    innerRadius: Property;
    innerRoundness: Property;
    outerRadius: Property;
    outerRoundness: Property;
    rotation: Property;
    points: Property;
    starType: StarType;
    fromJSON(json: Record<string, any>): StarShape;
    toJSON(): Record<string, any>;
}

declare class RoundedCornersShape extends Shape {
    readonly type = ShapeType.ROUNDED_CORNERS;
    roundness: Property;
    fromJSON(json: Record<string, any>): RoundedCornersShape;
    toJSON(): Record<string, any>;
}

declare class ShapeLayer extends Layer {
    readonly type = LayerType.SHAPE;
    shapes: Shape[];
    skew?: Property;
    skewAxis?: Property;
    createShape(type: ShapeType): Shape;
    createShapeFromJSON(json: Record<string, any>): Shape;
    fromJSON(json: Record<string, any>): ShapeLayer;
    toJSON(): Record<string, any>;
}

declare class SolidLayer extends Layer {
    readonly type = LayerType.SOLID;
    solidColor: string;
    solidHeight: number;
    solidWidth: number;
    fromJSON(json: Record<string, any>): SolidLayer;
    toJSON(): Record<string, any>;
}

declare class TextLayer extends Layer {
    readonly type = LayerType.TEXT;
    textData?: any;
    fromJSON(json: Record<string, any>): TextLayer;
    toJSON(): Record<string, any>;
}

declare class PrecompositionAsset extends Asset {
    readonly type = AssetType.PRECOMPOSITION;
    layers: Layer[];
    id: string;
    timeRemap: any;
    fromJSON(json: Record<string, any>): PrecompositionAsset;
    toJSON(): Record<string, any>;
}

declare class Marker {
    comment: string;
    duration: number;
    time: number;
    fromJSON(json: Record<string, any>): Marker;
    toJSON(): Record<string, any>;
}

declare class Meta {
    author?: string;
    keywords: string[];
    generator: string | undefined;
    description?: string;
    themeColor?: string;
    protected parent: any;
    constructor(parent: any);
    fromJSON(json: Record<string, any>): Meta;
    toJSON(): Record<string, any>;
}

declare class Animation {
    assets: Asset[];
    frameRate: number;
    height: number;
    inPoint: number;
    is3D: boolean;
    layers: Layer[];
    markers: Marker[];
    meta: Meta;
    name: string;
    outPoint: number;
    version: string;
    width: number;
    static fromURL(url: string): Promise<Animation>;
    static isLottie(json: Record<string, any>): boolean;
    get colors(): string[];
    get colorsVerbose(): Record<string, any>;
    get textLayers(): Record<string, any>;
    parentPath(shape: any, paths?: string[]): string[];
    get duration(): number;
    get fileSize(): number;
    get totalFrames(): number;
    createAsset(type: AssetType): Asset;
    createAssetFromJSON(json: Record<string, any>): Asset;
    createLayer(type: LayerType): Layer;
    createLayerFromJSON(json: Record<string, any>): Layer;
    createMarker(): Marker;
    createMarkerFromJSON(json: Record<string, any>): Marker;
    fromJSON(json: Record<string, any>): Animation;
    getLayerById(id: string): Layer | undefined;
    getLayersByClassName(className: string): Layer[];
    getLayersByType(type: LayerType): Layer[];
    toJSON(key?: string): Record<string, any> | undefined;
}

declare class Mask {
    isInverted: boolean;
    name: string;
    opacity: any;
    points: any;
    mode: MaskMode;
    fromJSON(json: Record<string, any>): Mask;
    toJSON(): Record<string, any>;
}

declare function useRegistry(): Map<Property, any>;

declare function rgbaToHex(rgba: number[]): string;
declare function hexToRgba(hex: string, alpha: number): number[];

export { Animation, Asset, AssetType, BlendMode, EllipseShape, FillRuleType, FillShape, Gradient, GradientFillShape, GradientFillType, GradientStop, GradientStrokeShape, GradientStrokeType, GroupLayer, GroupShape, ImageAsset, ImageLayer, KeyFrame, Layer, LayerType, LineCapType, LineJoinType, Marker, Mask, MaskMode, Meta, PathShape, PrecompositionAsset, PrecompositionLayer, Property, PropertyType, RectangleShape, RepeaterComposite, RepeaterShape, RoundedCornersShape, Shape, ShapeLayer, ShapeType, SolidLayer, StarShape, StarType, StrokeShape, TextLayer, TrimMode, TrimShape, hexToRgba, rgbaToHex, useRegistry };

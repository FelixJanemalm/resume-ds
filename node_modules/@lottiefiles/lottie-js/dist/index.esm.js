/*!
 * @lottiefiles/lottie-js - v0.2.1
 * Compiled Tue, 19 Oct 2021 08:57:10 UTC
 *
 * Copyright LottieFiles. All rights reserved.
 */
import fetch from 'cross-fetch';

class Asset {
  constructor(parent) {
    this.parent = parent;
  }
}

class ImageAsset extends Asset {
  fromJSON(json) {
    this.data = json.p;
    this.id = json.id;
    this.height = json.h;
    this.path = json.u;
    this.width = json.w;
    return this;
  }
  toJSON() {
    return {
      h: this.height,
      i: this.id,
      p: this.data,
      u: this.path,
      w: this.width
    };
  }
}

var AssetType;
(function(AssetType2) {
  AssetType2[AssetType2["PRECOMPOSITION"] = 0] = "PRECOMPOSITION";
  AssetType2[AssetType2["IMAGE"] = 1] = "IMAGE";
})(AssetType || (AssetType = {}));

class PrecompositionAsset extends Asset {
  constructor() {
    super(...arguments);
    this.type = AssetType.PRECOMPOSITION;
    this.layers = [];
    this.id = "";
  }
  fromJSON(json) {
    this.id = json.id;
    this.timeRemap = json.tm;
    this.layers = json.layers.map((jLayer) => this.parent.createLayerFromJSON(jLayer)).filter(Boolean);
    return this;
  }
  toJSON() {
    return {
      id: this.id,
      layers: this.layers,
      tm: this.timeRemap
    };
  }
}

var BlendMode;
(function(BlendMode2) {
  BlendMode2[BlendMode2["NORMAL"] = 0] = "NORMAL";
  BlendMode2[BlendMode2["MULTIPLY"] = 1] = "MULTIPLY";
  BlendMode2[BlendMode2["SCREEN"] = 2] = "SCREEN";
  BlendMode2[BlendMode2["OVERLAY"] = 3] = "OVERLAY";
  BlendMode2[BlendMode2["DARKEN"] = 4] = "DARKEN";
  BlendMode2[BlendMode2["LIGHTEN"] = 5] = "LIGHTEN";
  BlendMode2[BlendMode2["COLOR_DODGE"] = 6] = "COLOR_DODGE";
  BlendMode2[BlendMode2["COLOR_BURN"] = 7] = "COLOR_BURN";
  BlendMode2[BlendMode2["HARD_LIGHT"] = 8] = "HARD_LIGHT";
  BlendMode2[BlendMode2["SOFT_LIGHT"] = 9] = "SOFT_LIGHT";
  BlendMode2[BlendMode2["DIFFERENCE"] = 10] = "DIFFERENCE";
  BlendMode2[BlendMode2["EXCLUSION"] = 11] = "EXCLUSION";
  BlendMode2[BlendMode2["HUE"] = 12] = "HUE";
  BlendMode2[BlendMode2["SATURATION"] = 13] = "SATURATION";
  BlendMode2[BlendMode2["COLOR"] = 14] = "COLOR";
  BlendMode2[BlendMode2["LUMINOSITY"] = 15] = "LUMINOSITY";
})(BlendMode || (BlendMode = {}));

var FillRuleType;
(function(FillRuleType2) {
  FillRuleType2[FillRuleType2["EVEN_ODD"] = 1] = "EVEN_ODD";
  FillRuleType2[FillRuleType2["NONZERO"] = 2] = "NONZERO";
})(FillRuleType || (FillRuleType = {}));

var GradientFillType;
(function(GradientFillType2) {
  GradientFillType2[GradientFillType2["NONE"] = 0] = "NONE";
  GradientFillType2[GradientFillType2["LINEAR"] = 1] = "LINEAR";
  GradientFillType2[GradientFillType2["RADIAL"] = 2] = "RADIAL";
  GradientFillType2[GradientFillType2["ANGULAR"] = 4] = "ANGULAR";
  GradientFillType2[GradientFillType2["REFLECTED"] = 5] = "REFLECTED";
  GradientFillType2[GradientFillType2["DIAMOND"] = 6] = "DIAMOND";
})(GradientFillType || (GradientFillType = {}));

var GradientStrokeType;
(function(GradientStrokeType2) {
  GradientStrokeType2[GradientStrokeType2["LINEAR"] = 1] = "LINEAR";
  GradientStrokeType2[GradientStrokeType2["RADIAL"] = 2] = "RADIAL";
})(GradientStrokeType || (GradientStrokeType = {}));

var LayerType;
(function(LayerType2) {
  LayerType2[LayerType2["PRECOMPOSITION"] = 0] = "PRECOMPOSITION";
  LayerType2[LayerType2["SOLID"] = 1] = "SOLID";
  LayerType2[LayerType2["IMAGE"] = 2] = "IMAGE";
  LayerType2[LayerType2["GROUP"] = 3] = "GROUP";
  LayerType2[LayerType2["SHAPE"] = 4] = "SHAPE";
  LayerType2[LayerType2["TEXT"] = 5] = "TEXT";
  LayerType2[LayerType2["AUDIO"] = 6] = "AUDIO";
  LayerType2[LayerType2["VIDEO_PLACEHOLDER"] = 7] = "VIDEO_PLACEHOLDER";
  LayerType2[LayerType2["IMAGE_SEQUENCE"] = 8] = "IMAGE_SEQUENCE";
  LayerType2[LayerType2["VIDEO"] = 9] = "VIDEO";
  LayerType2[LayerType2["IMAGE_PLACEHOLDER"] = 10] = "IMAGE_PLACEHOLDER";
  LayerType2[LayerType2["GUIDE"] = 11] = "GUIDE";
  LayerType2[LayerType2["ADJUSTMENT"] = 12] = "ADJUSTMENT";
  LayerType2[LayerType2["CAMERA"] = 13] = "CAMERA";
  LayerType2[LayerType2["LIGHT"] = 14] = "LIGHT";
})(LayerType || (LayerType = {}));

var LineCapType;
(function(LineCapType2) {
  LineCapType2[LineCapType2["BUTT"] = 1] = "BUTT";
  LineCapType2[LineCapType2["ROUND"] = 2] = "ROUND";
  LineCapType2[LineCapType2["PROJECTING"] = 3] = "PROJECTING";
})(LineCapType || (LineCapType = {}));

var LineJoinType;
(function(LineJoinType2) {
  LineJoinType2[LineJoinType2["MITER"] = 1] = "MITER";
  LineJoinType2[LineJoinType2["ROUND"] = 2] = "ROUND";
  LineJoinType2[LineJoinType2["BEVEL"] = 3] = "BEVEL";
})(LineJoinType || (LineJoinType = {}));

var MaskMode;
(function(MaskMode2) {
  MaskMode2["None"] = "n";
  MaskMode2["Add"] = "a";
  MaskMode2["Subtract"] = "s";
  MaskMode2["Intersect"] = "i";
  MaskMode2["Lighten"] = "l";
  MaskMode2["Darken"] = "d";
  MaskMode2["Difference"] = "f";
})(MaskMode || (MaskMode = {}));

var PropertyType;
(function(PropertyType2) {
  PropertyType2["ANCHOR"] = "a";
  PropertyType2["OPACITY"] = "o";
  PropertyType2["POSITION"] = "p";
  PropertyType2["ROTATION"] = "r";
  PropertyType2["ROTATION_X"] = "rx";
  PropertyType2["ROTATION_Y"] = "ry";
  PropertyType2["ROTATION_Z"] = "rz";
  PropertyType2["SCALE"] = "s";
  PropertyType2["SKEW_AXIS"] = "sa";
  PropertyType2["SKEW"] = "sk";
  PropertyType2["SHAPE"] = "sh";
  PropertyType2["EXPANSION"] = "x";
  PropertyType2["FEATHER"] = "f";
  PropertyType2["SIZE"] = "sz";
  PropertyType2["ROUNDNESS"] = "rd";
  PropertyType2["MITER_LIMIT"] = "ml";
  PropertyType2["STROKE_WIDTH"] = "sw";
  PropertyType2["NUMBER"] = "nu";
  PropertyType2["COLOR"] = "cl";
  PropertyType2["ORIENTATION"] = "or";
})(PropertyType || (PropertyType = {}));

var ShapeType;
(function(ShapeType2) {
  ShapeType2["ELLIPSE"] = "el";
  ShapeType2["FILL"] = "fl";
  ShapeType2["GRADIENT_FILL"] = "gf";
  ShapeType2["GRADIENT_STROKE"] = "gs";
  ShapeType2["GROUP"] = "gr";
  ShapeType2["MERGE"] = "mm";
  ShapeType2["OFFSET_PATH"] = "op";
  ShapeType2["PATH"] = "sh";
  ShapeType2["RECTANGLE"] = "rc";
  ShapeType2["REPEATER"] = "rp";
  ShapeType2["ROUNDED_CORNERS"] = "rd";
  ShapeType2["STAR"] = "sr";
  ShapeType2["STROKE"] = "st";
  ShapeType2["TRIM"] = "tm";
  ShapeType2["TWIST"] = "tw";
})(ShapeType || (ShapeType = {}));

var TrimMode;
(function(TrimMode2) {
  TrimMode2[TrimMode2["SIMULTANEOUSLY"] = 1] = "SIMULTANEOUSLY";
  TrimMode2[TrimMode2["INDIVIDUALLY"] = 2] = "INDIVIDUALLY";
})(TrimMode || (TrimMode = {}));

var RepeaterComposite;
(function(RepeaterComposite2) {
  RepeaterComposite2[RepeaterComposite2["ABOVE"] = 1] = "ABOVE";
  RepeaterComposite2[RepeaterComposite2["BELOW"] = 2] = "BELOW";
})(RepeaterComposite || (RepeaterComposite = {}));

var StarType;
(function(StarType2) {
  StarType2[StarType2["STAR"] = 1] = "STAR";
  StarType2[StarType2["POLYGON"] = 2] = "POLYGON";
})(StarType || (StarType = {}));

class KeyFrame {
  constructor(frame = 0, value = 0) {
    this.frame = 0;
    this.value = 0;
    this.hold = false;
    this.frame = frame;
    this.value = value;
  }
  fromJSON(json) {
    this.frame = json.t;
    this.value = json.s;
    const hasFrameTangents = "i" in json && "o" in json;
    const hasValueTangents = "ti" in json && "to" in json;
    this.frameInTangent = hasFrameTangents ? [json.i.x, json.i.y] : void 0;
    this.frameOutTangent = hasFrameTangents ? [json.o.x, json.o.y] : void 0;
    this.valueInTangent = hasValueTangents ? ["x" in json.ti ? json.ti.x : json.ti[0], "y" in json.ti ? json.ti.y : json.ti[1]] : void 0;
    this.valueOutTangent = hasValueTangents ? ["x" in json.to ? json.to.x : json.to[0], "y" in json.to ? json.to.y : json.to[1]] : void 0;
    this.hold = "h" in json && json.h;
    return this;
  }
  toJSON() {
    const json = {
      t: this.frame,
      s: this.value
    };
    if (this.hold) {
      json.h = 1;
    } else if (this.frameInTangent && this.frameOutTangent) {
      json.i = {x: this.frameInTangent[0], y: this.frameInTangent[1]};
      json.o = {x: this.frameOutTangent[0], y: this.frameOutTangent[1]};
    }
    if (this.valueInTangent && this.valueOutTangent) {
      json.ti = [this.valueInTangent[0], this.valueInTangent[1]];
      json.to = [this.valueOutTangent[0], this.valueOutTangent[1]];
    }
    return json;
  }
}

const registry = new Map();
function useRegistry() {
  return registry;
}

class Property {
  constructor(parent, type, values = []) {
    this.UID = 0;
    this.isAnimated = false;
    this.index = 0;
    this.values = [];
    this._parent = parent;
    this.type = type;
    this.values = values;
    this.isAnimated = values.length > 1;
    useRegistry().set(this, parent);
  }
  getParent() {
    return this._parent;
  }
  fromJSON(json) {
    this.expression = "x" in json ? json.x : void 0;
    this.index = json.ix;
    this.isAnimated = json.a === 1;
    this.values = this.isAnimated ? json.k.map((v) => new KeyFrame().fromJSON(v)) : [new KeyFrame().fromJSON({t: 0, s: json.k})];
    if (this.type === PropertyType.COLOR) {
      this.maxColors = "p" in json ? json.p : void 0;
    }
    return this;
  }
  toJSON() {
    let value;
    if (this.isAnimated === false) {
      value = this.values.length ? this.values[0].value : 0;
    } else {
      value = this.values;
    }
    return {
      x: this.expression,
      ix: this.index,
      a: this.isAnimated ? 1 : 0,
      k: value,
      p: this.maxColors
    };
  }
}

class GradientStop {
  constructor(offset = 0, color = []) {
    this.offset = offset;
    this.color = color;
  }
  get hasAlpha() {
    return this.color.length > 3;
  }
  get red() {
    return this.color[0];
  }
  get green() {
    return this.color[1];
  }
  get blue() {
    return this.color[2];
  }
  get alpha() {
    return this.color[3];
  }
}
class GradientColorsProperty extends Property {
  constructor() {
    super(...arguments);
    this.colorCount = 0;
  }
  keyframeValue(index) {
    if (index >= this.values.length)
      return [];
    return this.values[index].value;
  }
  keyframeHasAlpha(index) {
    return this.keyframeValue(index).length == this.colorCount * 6;
  }
  keframeStops(index) {
    const values = this.keyframeValue(index);
    const stops = [];
    const hasAlpha = this.keyframeHasAlpha(index);
    for (let i = 0; i < this.colorCount; i++) {
      const color = values.slice(i, 3);
      if (hasAlpha)
        color.push(values[this.colorCount * 4 + i * 2]);
      stops.push(new GradientStop(values[i * 4], color));
    }
    return stops;
  }
  setKeyframeStops(index, stops) {
    if (index >= this.values.length)
      return;
    if (stops.length > this.colorCount)
      this.colorCount = stops.length;
    this.values[index].value = this.stopsToArray(stops);
  }
  addKeyframe(frame, stops) {
    const keyframe = new KeyFrame(frame, this.stopsToArray(stops));
    if (stops.length > this.colorCount)
      this.colorCount = stops.length;
    this.values.push(keyframe);
    return keyframe;
  }
  stopsToArray(stops) {
    let hasAlpha = false;
    const result = [];
    for (const color of stops) {
      result.push(color.offset);
      result.push(color.red);
      result.push(color.green);
      result.push(color.blue);
      if (color.hasAlpha)
        hasAlpha = true;
    }
    if (hasAlpha) {
      for (const color of stops) {
        result.push(color.offset);
        result.push(color.alpha !== void 0 ? color.alpha : 1);
      }
    }
    return result;
  }
}
class Gradient {
  constructor() {
    this.gradientColors = new GradientColorsProperty(this, PropertyType.COLOR);
  }
  get colorCount() {
    return this.gradientColors.colorCount;
  }
  set colorCount(count) {
    this.gradientColors.colorCount = count;
  }
  toJSON() {
    return {
      p: this.colorCount,
      k: this.gradientColors
    };
  }
  fromJSON(json) {
    this.gradientColors.fromJSON(json.k);
    this.colorCount = json.p;
    return this;
  }
}

class Layer {
  constructor(parent) {
    this.autoOrient = false;
    this.blendMode = BlendMode.NORMAL;
    this.classNames = [];
    this.height = 0;
    this.id = "";
    this.inPoint = 0;
    this.is3D = false;
    this.name = "";
    this.outPoint = 0;
    this.startTime = 0;
    this.timeStretch = 1;
    this.width = 0;
    this.opacity = new Property(this, PropertyType.OPACITY);
    this.position = new Property(this, PropertyType.POSITION);
    this.anchor = new Property(this, PropertyType.ANCHOR);
    this.scale = new Property(this, PropertyType.SCALE);
    this.parent = parent;
  }
  get colors() {
    const colors = new Set();
    const registry = useRegistry();
    [...registry.keys()].filter((p) => registry.get(p) === this && p.type === PropertyType.COLOR).forEach((cp) => {
      cp.values.forEach((v) => {
        colors.add(JSON.stringify(v.value));
      });
    });
    return Array.from(colors).map((c) => JSON.parse(c));
  }
  get totalFrames() {
    return this.outPoint - this.inPoint;
  }
}

class GroupLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerType.GROUP;
  }
  fromJSON(json) {
    this.autoOrient = json.ao === 1;
    this.blendMode = json.bm;
    this.effects = json.ef;
    this.height = json.h;
    this.id = json.ld;
    this.index = json.ind;
    this.inPoint = json.ip;
    this.is3D = json.ddd;
    this.name = json.nm;
    this.outPoint = json.op;
    this.parent = json.parent;
    this.startTime = json.st;
    this.timeStretch = json.sr;
    this.width = json.w;
    if ("cl" in json) {
      this.classNames = json.cl.split(" ");
    }
    this.opacity.fromJSON(json.ks.o);
    this.position.fromJSON(json.ks.p);
    this.anchor.fromJSON(json.ks.a);
    this.scale.fromJSON(json.ks.s);
    this.rotation = new Property(this, PropertyType.ROTATION).fromJSON(json.ks.r);
    return this;
  }
  toJSON() {
    return {
      ao: this.autoOrient ? 1 : 0,
      bm: this.blendMode,
      cl: this.classNames.length ? this.classNames.join(" ") : void 0,
      ddd: this.is3D ? 1 : 0,
      ef: this.effects,
      h: this.height,
      ind: this.index,
      ip: this.inPoint,
      ks: {
        a: this.anchor,
        o: this.opacity,
        p: this.position,
        r: this.rotation,
        s: this.scale
      },
      ln: this.id,
      nm: this.name,
      op: this.outPoint,
      parent: this.parent,
      sr: this.timeStretch,
      st: this.startTime,
      ty: this.type,
      w: this.width
    };
  }
}

class ImageLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerType.IMAGE;
  }
  fromJSON(json) {
    this.autoOrient = json.ao === 1;
    this.blendMode = json.bm;
    this.effects = json.ef;
    this.height = json.h;
    this.id = json.ld;
    this.index = json.ind;
    this.inPoint = json.ip;
    this.is3D = json.ddd;
    this.name = json.nm;
    this.outPoint = json.op;
    this.parent = json.parent;
    this.startTime = json.st;
    this.timeStretch = json.sr;
    this.width = json.w;
    if ("cl" in json) {
      this.classNames = json.cl.split(" ");
    }
    this.opacity.fromJSON(json.ks.o);
    this.position.fromJSON(json.ks.p);
    this.anchor.fromJSON(json.ks.a);
    this.scale.fromJSON(json.ks.s);
    this.rotation = new Property(this, PropertyType.ROTATION).fromJSON(json.ks.r);
    this.refId = json.refId;
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      ao: this.autoOrient ? 1 : 0,
      bm: this.blendMode,
      cl: this.classNames.length ? this.classNames.join(" ") : void 0,
      ddd: this.is3D ? 1 : 0,
      ef: this.effects,
      h: this.height,
      ind: this.index,
      ip: this.inPoint,
      ks: {
        a: this.anchor,
        o: this.opacity,
        p: this.position,
        r: this.rotation,
        s: this.scale
      },
      ln: this.id,
      nm: this.name,
      op: this.outPoint,
      parent: this.parent,
      sr: this.timeStretch,
      st: this.startTime,
      w: this.width,
      refId: this.refId
    };
  }
}

class PrecompositionLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerType.PRECOMPOSITION;
  }
  fromJSON(json) {
    this.autoOrient = json.ao === 1;
    this.blendMode = json.bm;
    this.effects = json.ef;
    this.height = json.h;
    this.id = json.ld;
    this.index = json.ind;
    this.inPoint = json.ip;
    this.is3D = json.ddd;
    this.name = json.nm;
    this.outPoint = json.op;
    this.parent = json.parent;
    this.startTime = json.st;
    this.timeStretch = json.sr;
    this.width = json.w;
    if ("cl" in json) {
      this.classNames = json.cl.split(" ");
    }
    this.opacity.fromJSON(json.ks.o);
    this.position.fromJSON(json.ks.p);
    this.anchor.fromJSON(json.ks.a);
    this.scale.fromJSON(json.ks.s);
    this.rotation = new Property(this, PropertyType.ROTATION).fromJSON(json.ks.r);
    this.refId = json.refId;
    return this;
  }
  toJSON() {
    return {
      ao: this.autoOrient ? 1 : 0,
      bm: this.blendMode,
      cl: this.classNames.length ? this.classNames.join(" ") : void 0,
      ddd: this.is3D ? 1 : 0,
      ef: this.effects,
      h: this.height,
      ind: this.index,
      ip: this.inPoint,
      ks: {
        a: this.anchor,
        o: this.opacity,
        p: this.position,
        r: this.rotation,
        s: this.scale
      },
      ln: this.id,
      nm: this.name,
      op: this.outPoint,
      parent: this.parent,
      refId: this.refId,
      sr: this.timeStretch,
      st: this.startTime,
      ty: this.type,
      w: this.width
    };
  }
}

class Shape {
  constructor(parent) {
    this.isHidden = false;
    this.parent = parent;
  }
}

class EllipseShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.ELLIPSE;
    this.position = new Property(this, PropertyType.POSITION);
    this.size = new Property(this, PropertyType.SIZE);
    this.direction = 1;
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.position.fromJSON(json.p);
    this.size.fromJSON(json.s);
    this.direction = json.d;
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      p: this.position,
      s: this.size,
      d: this.direction
    };
  }
}

class FillShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.FILL;
    this.blendMode = BlendMode.NORMAL;
    this.color = new Property(this, PropertyType.COLOR);
    this.fillRule = FillRuleType.EVEN_ODD;
    this.opacity = new Property(this, PropertyType.OPACITY);
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.blendMode = json.bm;
    this.color.fromJSON(json.c);
    this.fillRule = json.r in FillRuleType ? json.r : FillRuleType.EVEN_ODD;
    this.opacity.fromJSON(json.o);
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      bm: this.blendMode,
      c: this.color,
      r: this.fillRule,
      o: this.opacity
    };
  }
}

class GradientFillShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.GRADIENT_FILL;
    this.blendMode = BlendMode.NORMAL;
    this.endPoint = new Property(this, PropertyType.POSITION);
    this.gradientColors = new Gradient();
    this.gradientType = GradientFillType.LINEAR;
    this.highlightAngle = new Property(this, PropertyType.NUMBER);
    this.highlightLength = new Property(this, PropertyType.NUMBER);
    this.opacity = new Property(this, PropertyType.OPACITY);
    this.startPoint = new Property(this, PropertyType.POSITION);
    this.fillRule = FillRuleType.EVEN_ODD;
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.blendMode = json.bm;
    this.endPoint.fromJSON(json.e);
    this.gradientColors.fromJSON(json.g);
    this.gradientType = json.t;
    this.opacity.fromJSON(json.o);
    this.startPoint.fromJSON(json.s);
    this.fillRule = json.r;
    if (this.gradientType === GradientFillType.LINEAR) {
      this.highlightAngle.fromJSON(json.a);
      this.highlightLength.fromJSON(json.h);
    }
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      bm: this.blendMode,
      e: this.endPoint,
      g: this.gradientColors,
      t: this.gradientType,
      a: this.highlightAngle,
      h: this.highlightLength,
      o: this.opacity,
      r: this.fillRule,
      s: this.startPoint
    };
  }
}

class PathShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.PATH;
    this.vertices = new Property(this, PropertyType.SHAPE);
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.itemIndex = json.ind;
    this.shapeIndex = json.ix;
    this.direction = json.d;
    this.vertices = json.ks;
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      ind: this.itemIndex,
      ix: this.shapeIndex,
      d: this.direction,
      ks: this.vertices
    };
  }
}

class RectangleShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.RECTANGLE;
    this.position = new Property(this, PropertyType.POSITION);
    this.roundness = new Property(this, PropertyType.ROUNDNESS);
    this.size = new Property(this, PropertyType.SIZE);
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.direction = json.d;
    this.position.fromJSON(json.p);
    this.roundness.fromJSON(json.r);
    this.size.fromJSON(json.s);
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      d: this.direction,
      p: this.position,
      r: this.roundness,
      s: this.size
    };
  }
}

class StrokeShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.STROKE;
    this.blendMode = BlendMode.NORMAL;
    this.color = new Property(this, PropertyType.COLOR);
    this.lineCapType = LineCapType.ROUND;
    this.lineJoinType = LineJoinType.ROUND;
    this.opacity = new Property(this, PropertyType.OPACITY);
    this.width = new Property(this, PropertyType.STROKE_WIDTH);
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.blendMode = json.bm in BlendMode ? json.bm : BlendMode.NORMAL;
    this.color.fromJSON(json.c);
    this.lineCapType = json.lc in LineCapType ? json.lc : LineCapType.ROUND;
    this.lineJoinType = json.lj in LineJoinType ? json.lj : LineJoinType.ROUND;
    this.miterLimit = json.ml;
    this.opacity.fromJSON(json.o);
    this.width.fromJSON(json.w);
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      bm: this.blendMode,
      c: this.color,
      lc: this.lineCapType,
      lj: this.lineJoinType,
      ml: this.miterLimit,
      o: this.opacity,
      w: this.width
    };
  }
}

class TrimShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.TRIM;
    this.blendMode = BlendMode.NORMAL;
    this.trimEnd = new Property(this, PropertyType.NUMBER);
    this.trimOffset = new Property(this, PropertyType.NUMBER);
    this.trimStart = new Property(this, PropertyType.NUMBER);
    this.trimMultipleShapes = TrimMode.SIMULTANEOUSLY;
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.blendMode = json.bm in BlendMode ? json.bm : BlendMode.NORMAL;
    this.trimEnd.fromJSON(json.e);
    this.trimOffset.fromJSON(json.o);
    this.trimStart.fromJSON(json.s);
    this.trimMultipleShapes = json.m in TrimMode ? json.m : TrimMode.INDIVIDUALLY;
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      bm: this.blendMode,
      e: this.trimEnd,
      o: this.trimOffset,
      s: this.trimStart,
      m: this.trimMultipleShapes
    };
  }
}

class GroupShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.GROUP;
    this.anchor = new Property(this, PropertyType.ANCHOR);
    this.blendMode = BlendMode.NORMAL;
    this.isHidden = false;
    this.numProperties = 0;
    this.opacity = new Property(this, PropertyType.OPACITY);
    this.position = new Property(this, PropertyType.POSITION);
    this.rotation = new Property(this, PropertyType.ROTATION);
    this.scale = new Property(this, PropertyType.SCALE);
    this.shapes = [];
    this.skew = new Property(this, PropertyType.SKEW);
    this.skewAxis = new Property(this, PropertyType.SKEW_AXIS);
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.blendMode = json.bm;
    this.contentPropertyIndex = json.cix;
    this.propertyIndex = json.ix;
    this.numProperties = json.np;
    this.shapes = json.it.map((jShape) => {
      try {
        if (jShape.ty !== "tr") {
          const nShape = this.createShape(jShape.ty);
          return nShape.fromJSON(jShape);
        }
        this.anchor.fromJSON(jShape.a);
        this.opacity.fromJSON(jShape.o);
        this.position.fromJSON(jShape.p);
        this.rotation.fromJSON(jShape.r);
        this.scale.fromJSON(jShape.s);
        if (jShape.sk) {
          this.skew.fromJSON(jShape.sk);
        }
        if (jShape.sa) {
          this.skewAxis.fromJSON(jShape.sa);
        }
      } catch (e) {
      }
      return false;
    }).filter(Boolean);
    return this;
  }
  createShape(type) {
    if (type === ShapeType.PATH) {
      return new PathShape(this);
    } else if (type === ShapeType.GROUP) {
      return new GroupShape(this);
    } else if (type === ShapeType.FILL) {
      return new FillShape(this);
    } else if (type === ShapeType.RECTANGLE) {
      return new RectangleShape(this);
    } else if (type === ShapeType.ELLIPSE) {
      return new EllipseShape(this);
    } else if (type === ShapeType.STROKE) {
      return new StrokeShape(this);
    } else if (type === ShapeType.GRADIENT_FILL) {
      return new GradientFillShape(this);
    } else if (type === ShapeType.TRIM) {
      return new TrimShape(this);
    }
    throw new Error(`Invalid or unknown shape type: ${type}`);
  }
  toJSON() {
    const shapes = JSON.parse(JSON.stringify(this.shapes));
    shapes.push({
      ty: "tr",
      nm: "Transform",
      a: this.anchor,
      o: this.opacity,
      p: this.position,
      r: this.rotation,
      s: this.scale,
      sk: this.skew,
      sa: this.skewAxis
    });
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      bm: this.blendMode,
      cix: this.contentPropertyIndex,
      it: shapes,
      ix: this.propertyIndex,
      np: this.numProperties
    };
  }
}

class ShapeLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerType.SHAPE;
    this.shapes = [];
  }
  createShape(type) {
    if (type === ShapeType.PATH) {
      return new PathShape(this);
    } else if (type === ShapeType.GROUP) {
      return new GroupShape(this);
    } else if (type === ShapeType.FILL) {
      return new FillShape(this);
    } else if (type === ShapeType.RECTANGLE) {
      return new RectangleShape(this);
    } else if (type === ShapeType.ELLIPSE) {
      return new EllipseShape(this);
    } else if (type === ShapeType.STROKE) {
      return new StrokeShape(this);
    } else if (type === ShapeType.GRADIENT_FILL) {
      return new GradientFillShape(this);
    } else if (type === ShapeType.TRIM) {
      return new TrimShape(this);
    }
    throw new Error(`Invalid or unknown shape type: ${type}`);
  }
  createShapeFromJSON(json) {
    try {
      const shape = this.createShape(json.ty);
      return shape.fromJSON(json);
    } catch (e) {
      throw new Error(`Unable to create shape from JSON: ${json.ty}`);
    }
  }
  fromJSON(json) {
    this.autoOrient = json.ao === 1;
    this.blendMode = json.bm;
    this.effects = json.ef;
    this.height = json.h;
    this.id = json.ld;
    this.index = json.ind;
    this.inPoint = json.ip;
    this.is3D = json.ddd;
    this.name = json.nm;
    this.outPoint = json.op;
    this.parent = json.parent;
    this.startTime = json.st;
    this.timeStretch = json.sr;
    this.width = json.w;
    this.classNames = "cl" in json ? json.cl.split(" ") : [];
    "o" in json.ks && this.opacity.fromJSON(json.ks.o);
    "p" in json.ks && this.position.fromJSON(json.ks.p);
    "a" in json.ks && this.anchor.fromJSON(json.ks.a);
    "s" in json.ks && this.scale.fromJSON(json.ks.s);
    if ("or" in json.ks) {
      this.orientation = new Property(this, PropertyType.ORIENTATION).fromJSON(json.ks.or);
    }
    if ("rx" in json.ks) {
      this.rotationX = new Property(this, PropertyType.ROTATION_X).fromJSON(json.ks.rx);
    }
    if ("ry" in json.ks) {
      this.rotationY = new Property(this, PropertyType.ROTATION_Y).fromJSON(json.ks.ry);
    }
    if ("rz" in json.ks) {
      this.rotationZ = new Property(this, PropertyType.ROTATION_Z).fromJSON(json.ks.rz);
    }
    if ("r" in json.ks) {
      this.rotation = new Property(this, PropertyType.ROTATION).fromJSON(json.ks.r);
    }
    this.skew = "sk" in json.ks ? new Property(this, PropertyType.SKEW).fromJSON(json.ks.sk) : void 0;
    this.skewAxis = "sa" in json.ks ? new Property(this, PropertyType.SKEW_AXIS).fromJSON(json.ks.sa) : void 0;
    this.shapes = json.shapes.map((jShape) => this.createShapeFromJSON(jShape)).filter(Boolean);
    return this;
  }
  toJSON() {
    return {
      ao: this.autoOrient ? 1 : 0,
      bm: this.blendMode,
      cl: this.classNames.length ? this.classNames.join(" ") : void 0,
      ddd: this.is3D ? 1 : 0,
      ef: this.effects,
      h: this.height,
      ind: this.index,
      ip: this.inPoint,
      ks: {
        a: this.anchor,
        o: this.opacity,
        p: this.position,
        r: this.rotation,
        s: this.scale,
        sk: this.skew,
        sa: this.skewAxis,
        rx: this.rotationX,
        ry: this.rotationY,
        rz: this.rotationZ,
        or: this.orientation
      },
      shapes: this.shapes.map((shape) => shape.toJSON()),
      ln: this.id,
      nm: this.name,
      op: this.outPoint,
      parent: this.parent,
      sr: this.timeStretch,
      st: this.startTime,
      ty: this.type,
      w: this.width
    };
  }
}

class SolidLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerType.SOLID;
    this.solidColor = "#000000";
    this.solidHeight = 1;
    this.solidWidth = 1;
  }
  fromJSON(json) {
    this.autoOrient = json.ao === 1;
    this.blendMode = json.bm;
    this.effects = json.ef;
    this.height = json.h;
    this.id = json.ld;
    this.index = json.ind;
    this.inPoint = json.ip;
    this.is3D = json.ddd;
    this.name = json.nm;
    this.outPoint = json.op;
    this.parent = json.parent;
    this.startTime = json.st;
    this.timeStretch = json.sr;
    this.width = json.w;
    if ("cl" in json) {
      this.classNames = json.cl.split(" ");
    }
    this.opacity.fromJSON(json.ks.o);
    this.position.fromJSON(json.ks.p);
    this.anchor.fromJSON(json.ks.a);
    this.scale.fromJSON(json.ks.s);
    this.rotation = new Property(this, PropertyType.ROTATION).fromJSON(json.ks.r);
    this.solidColor = json.sc;
    this.solidHeight = json.sh;
    this.solidWidth = json.sw;
    return this;
  }
  toJSON() {
    return {
      ao: this.autoOrient ? 1 : 0,
      bm: this.blendMode,
      cl: this.classNames.length ? this.classNames.join(" ") : void 0,
      ddd: this.is3D ? 1 : 0,
      ef: this.effects,
      h: this.height,
      ind: this.index,
      ip: this.inPoint,
      ks: {
        a: this.anchor,
        o: this.opacity,
        p: this.position,
        r: this.rotation,
        s: this.scale
      },
      ln: this.id,
      nm: this.name,
      op: this.outPoint,
      parent: this.parent,
      sc: this.solidColor,
      sh: this.solidHeight,
      sw: this.solidWidth,
      sr: this.timeStretch,
      st: this.startTime,
      ty: this.type,
      w: this.width
    };
  }
}

class TextLayer extends Layer {
  constructor() {
    super(...arguments);
    this.type = LayerType.TEXT;
  }
  fromJSON(json) {
    this.autoOrient = json.ao === 1;
    this.blendMode = json.bm;
    this.effects = json.ef;
    this.height = json.h;
    this.id = json.ld;
    this.index = json.ind;
    this.inPoint = json.ip;
    this.is3D = json.ddd;
    this.name = json.nm;
    this.outPoint = json.op;
    this.parent = json.parent;
    this.startTime = json.st;
    this.timeStretch = json.sr;
    this.width = json.w;
    if ("cl" in json) {
      this.classNames = json.cl.split(" ");
    }
    this.opacity.fromJSON(json.ks.o);
    this.position.fromJSON(json.ks.p);
    this.anchor.fromJSON(json.ks.a);
    this.scale.fromJSON(json.ks.s);
    this.rotation = new Property(this, PropertyType.ROTATION).fromJSON(json.ks.r);
    this.textData = json.t;
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      ao: this.autoOrient ? 1 : 0,
      bm: this.blendMode,
      cl: this.classNames.length ? this.classNames.join(" ") : void 0,
      ddd: this.is3D ? 1 : 0,
      ef: this.effects,
      h: this.height,
      ind: this.index,
      ip: this.inPoint,
      ks: {
        a: this.anchor,
        o: this.opacity,
        p: this.position,
        r: this.rotation,
        s: this.scale
      },
      ln: this.id,
      nm: this.name,
      op: this.outPoint,
      parent: this.parent,
      sr: this.timeStretch,
      st: this.startTime,
      w: this.width,
      t: this.textData
    };
  }
}

class Marker {
  constructor() {
    this.comment = "";
    this.duration = 0;
    this.time = 0;
  }
  fromJSON(json) {
    this.comment = json.cm;
    this.duration = json.dr;
    this.time = json.tm;
    return this;
  }
  toJSON() {
    return {
      cm: this.comment,
      dr: this.duration,
      tm: this.time
    };
  }
}

function rgbaToHex(rgba) {
  let r = (+rgba[0]).toString(16), g = (+rgba[1]).toString(16), b = (+rgba[2]).toString(16), a = Math.round(+rgba[3] * 255).toString(16);
  if (r.length == 1)
    r = "0" + r;
  if (g.length == 1)
    g = "0" + g;
  if (b.length == 1)
    b = "0" + b;
  if (a.length == 1)
    a = "0" + a;
  return "#" + r + g + b + a;
}
function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  if (alpha) {
    return [r / 255, g / 255, b / 255, alpha];
  }
  return [r / 255, g / 255, b / 255];
}

class Meta {
  constructor(parent) {
    this.keywords = [];
    this.generator = "@lottiefiles/lottie-js 0.2.1";
    this.parent = parent;
  }
  fromJSON(json) {
    this.author = json.a;
    this.keywords = "k" in json ? json.k.split(",").map((w) => w.trim()) : [json.k];
    this.generator = json.g;
    this.description = json.d;
    this.themeColor = json.tc;
    return this;
  }
  toJSON() {
    return {
      a: this.author,
      k: this.keywords.length ? this.keywords : void 0,
      g: this.generator,
      d: this.description,
      tc: this.themeColor
    };
  }
}

class Animation {
  constructor() {
    this.assets = [];
    this.frameRate = 0;
    this.height = 0;
    this.inPoint = 0;
    this.is3D = false;
    this.layers = [];
    this.markers = [];
    this.meta = new Meta(this);
    this.name = "";
    this.outPoint = 0;
    this.version = ``;
    this.width = 0;
  }
  static async fromURL(url) {
    if (typeof url !== "string") {
      throw new Error(`The url value must be a string`);
    }
    let json;
    try {
      const srcUrl = new URL(url);
      const result = await fetch(srcUrl.toString());
      json = await result.json();
    } catch (err) {
      throw new Error(`An error occurred while trying to load the Lottie file from URL`);
    }
    const anim = new Animation();
    return anim.fromJSON(json);
  }
  static isLottie(json) {
    const mandatory = ["v", "ip", "op", "layers", "fr", "w", "h"];
    return mandatory.every((field) => Object.prototype.hasOwnProperty.call(json, field));
  }
  get colors() {
    const colors = new Set();
    [...useRegistry().keys()].filter((p) => p.type === PropertyType.COLOR).forEach((cp) => {
      cp.values.forEach((v) => {
        const colorParts = v.value;
        colors.add(JSON.stringify([
          Math.round(colorParts[0] * 255),
          Math.round(colorParts[1] * 255),
          Math.round(colorParts[2] * 255),
          colorParts[3]
        ]));
      });
    });
    return Array.from(colors).map((c) => JSON.parse(c));
  }
  get colorsVerbose() {
    const colors = {};
    [...useRegistry().keys()].filter((p) => p.type === PropertyType.COLOR).forEach((cp, index) => {
      const parent = cp.getParent();
      const pathString = this.parentPath(parent);
      const pathCopy = pathString.slice();
      cp.values.forEach((v) => {
        pathCopy.unshift("Frame " + v.frame);
        pathCopy.unshift(index.toString());
        const colorParts = v.value;
        colors[pathCopy.join(".")] = rgbaToHex([
          Math.round(colorParts[0] * 255),
          Math.round(colorParts[1] * 255),
          Math.round(colorParts[2] * 255),
          colorParts[3]
        ]);
      });
    });
    return colors;
  }
  get textLayers() {
    const textLayers = {};
    const layers2 = this.getLayersByType(LayerType.TEXT);
    layers2.forEach((layer, index) => {
      textLayers[index + "." + layer.name] = layer.textData.d.k[0].s.t;
    });
    return textLayers;
  }
  parentPath(shape, paths = []) {
    if (shape.parent === void 0) {
      paths.push(shape.name);
      return paths;
    }
    paths.push(shape.name);
    return this.parentPath(shape.parent, paths);
  }
  get duration() {
    return this.totalFrames / this.frameRate;
  }
  get fileSize() {
    return new TextEncoder().encode(JSON.stringify(this)).length;
  }
  get totalFrames() {
    return this.outPoint - this.inPoint;
  }
  createAsset(type) {
    if (type === AssetType.PRECOMPOSITION) {
      return new PrecompositionAsset(this);
    } else if (type === AssetType.IMAGE) {
      return new ImageAsset(this);
    }
    throw new Error(`Invalid or unknown asset type ${type}`);
  }
  createAssetFromJSON(json) {
    try {
      const asset = this.createAsset("layers" in json ? AssetType.PRECOMPOSITION : AssetType.IMAGE);
      return asset.fromJSON(json);
    } catch (e) {
      throw new Error(`Unable to create asset from JSON`);
    }
  }
  createLayer(type) {
    if (type === LayerType.PRECOMPOSITION) {
      return new PrecompositionLayer(this);
    } else if (type === LayerType.SHAPE) {
      return new ShapeLayer(this);
    } else if (type === LayerType.GROUP) {
      return new GroupLayer(this);
    } else if (type === LayerType.SOLID) {
      return new SolidLayer(this);
    } else if (type === LayerType.IMAGE) {
      return new ImageLayer(this);
    } else if (type === LayerType.TEXT) {
      return new TextLayer(this);
    }
    throw new Error(`Invalid or unknown layer type: ${type}`);
  }
  createLayerFromJSON(json) {
    try {
      const layer = this.createLayer(json.ty);
      return layer.fromJSON(json);
    } catch (e) {
      console.log(e);
      throw new Error(`Unable to create layer type from JSON: ${json.ty}`);
    }
  }
  createMarker() {
    return new Marker();
  }
  createMarkerFromJSON(json) {
    try {
      const marker = this.createMarker();
      return marker.fromJSON(json);
    } catch (e) {
      console.log(e);
      throw new Error(`Unable to create marker from JSON`);
    }
  }
  fromJSON(json) {
    if (Animation.isLottie(json) === false) {
      throw new Error(`The given object is not a valid Lottie JSON structure`);
    }
    this.frameRate = json.fr;
    this.height = json.h;
    this.inPoint = json.ip;
    this.is3D = json.ddd;
    this.name = json.nm;
    this.outPoint = json.op;
    this.version = json.v;
    this.width = json.w;
    this.assets = json.assets.map((jAsset) => this.createAssetFromJSON(jAsset)).filter(Boolean);
    this.layers = json.layers.map((jLayer) => this.createLayerFromJSON(jLayer)).filter(Boolean);
    this.markers = json.markers.map((jMarker) => this.createMarkerFromJSON(jMarker)).filter(Boolean);
    if ("meta" in json) {
      this.meta.fromJSON(json.meta);
    }
    return this;
  }
  getLayerById(id) {
    if (typeof id !== "string") {
      throw new Error(`ID value must be a string`);
    }
    return this.layers.find((layer) => layer.id === id);
  }
  getLayersByClassName(className) {
    if (typeof className !== "string") {
      throw new Error(`Class name value must be a string`);
    }
    return this.layers.filter((layer) => layer.classNames.includes(className));
  }
  getLayersByType(type) {
    if (type in LayerType === false) {
      throw new Error(`Type value must be a valid LayerType value`);
    }
    return this.layers.filter((layer) => layer.type === type);
  }
  toJSON(key) {
    if (key) {
      return void 0;
    }
    return {
      assets: this.assets,
      ddd: this.is3D ? 1 : 0,
      fr: this.frameRate,
      h: this.height,
      ip: this.inPoint,
      layers: this.layers.map((layer) => layer.toJSON()),
      markers: this.markers.map((marker) => marker.toJSON()),
      meta: this.meta,
      nm: this.name,
      op: this.outPoint,
      v: this.version || "5.6.0",
      w: this.width
    };
  }
}

class Mask {
  constructor() {
    this.isInverted = false;
    this.name = "";
    this.mode = MaskMode.Add;
  }
  fromJSON(json) {
    this.isInverted = json.inv;
    this.mode = json.mode;
    this.name = json.nm;
    this.points = json.pt;
    this.opacity = json.o;
    return this;
  }
  toJSON() {
    return {
      inv: this.isInverted,
      mode: this.mode,
      nm: this.name,
      o: this.opacity,
      pt: this.points
    };
  }
}

class GradientStrokeShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.GRADIENT_STROKE;
    this.blendMode = BlendMode.NORMAL;
    this.endPoint = new Property(this, PropertyType.POSITION);
    this.gradientColors = new Gradient();
    this.gradientType = GradientFillType.LINEAR;
    this.highlightAngle = new Property(this, PropertyType.NUMBER);
    this.highlightLength = new Property(this, PropertyType.NUMBER);
    this.opacity = new Property(this, PropertyType.OPACITY);
    this.startPoint = new Property(this, PropertyType.POSITION);
    this.lineCapType = LineCapType.ROUND;
    this.lineJoinType = LineJoinType.ROUND;
    this.width = new Property(this, PropertyType.STROKE_WIDTH);
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.blendMode = json.bm;
    this.opacity.fromJSON(json.o);
    this.endPoint.fromJSON(json.e);
    this.gradientColors.fromJSON(json.g);
    this.gradientType = json.t;
    this.startPoint.fromJSON(json.s);
    if (this.gradientType === GradientFillType.LINEAR) {
      this.highlightAngle.fromJSON(json.a);
      this.highlightLength.fromJSON(json.h);
    }
    this.lineCapType = json.lc in LineCapType ? json.lc : LineCapType.ROUND;
    this.lineJoinType = json.lj in LineJoinType ? json.lj : LineJoinType.ROUND;
    this.miterLimit = json.ml;
    this.width.fromJSON(json.w);
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      bm: this.blendMode,
      o: this.opacity,
      e: this.endPoint,
      g: this.gradientColors,
      t: this.gradientType,
      a: this.highlightAngle,
      h: this.highlightLength,
      s: this.startPoint,
      lc: this.lineCapType,
      lj: this.lineJoinType,
      ml: this.miterLimit,
      w: this.width
    };
  }
}

class RepeaterShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.REPEATER;
    this.anchor = new Property(this, PropertyType.ANCHOR);
    this.startOpacity = new Property(this, PropertyType.OPACITY);
    this.endOpacity = new Property(this, PropertyType.OPACITY);
    this.position = new Property(this, PropertyType.POSITION);
    this.rotation = new Property(this, PropertyType.ROTATION);
    this.scale = new Property(this, PropertyType.SCALE);
    this.shapes = [];
    this.skew = new Property(this, PropertyType.SKEW);
    this.skewAxis = new Property(this, PropertyType.SKEW_AXIS);
    this.copies = new Property(this, PropertyType.NUMBER);
    this.offset = new Property(this, PropertyType.NUMBER);
    this.composition = RepeaterComposite.ABOVE;
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.copies.fromJSON(json.c);
    this.composition = json.m;
    this.offset.fromJSON(json.o);
    this.anchor.fromJSON(json.tr.a);
    this.startOpacity.fromJSON(json.tr.so);
    this.endOpacity.fromJSON(json.tr.eo);
    this.position.fromJSON(json.tr.p);
    this.rotation.fromJSON(json.tr.r);
    this.scale.fromJSON(json.tr.s);
    if (json.tr.sk) {
      this.skew.fromJSON(json.tr.sk);
    }
    if (json.tr.sa) {
      this.skewAxis.fromJSON(json.tr.sa);
    }
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      m: this.composition,
      c: this.copies,
      o: this.offset,
      tr: {
        a: this.anchor,
        so: this.startOpacity,
        eo: this.endOpacity,
        p: this.position,
        r: this.rotation,
        s: this.scale,
        sk: this.skew,
        sa: this.skewAxis
      }
    };
  }
}

class StarShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.STAR;
    this.position = new Property(this, PropertyType.POSITION);
    this.innerRadius = new Property(this, PropertyType.NUMBER);
    this.innerRoundness = new Property(this, PropertyType.NUMBER);
    this.outerRadius = new Property(this, PropertyType.NUMBER);
    this.outerRoundness = new Property(this, PropertyType.NUMBER);
    this.rotation = new Property(this, PropertyType.ROTATION);
    this.points = new Property(this, PropertyType.NUMBER);
    this.starType = StarType.STAR;
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.position.fromJSON(json.p);
    this.innerRadius.fromJSON(json.ir);
    this.innerRoundness.fromJSON(json.is);
    this.outerRadius.fromJSON(json.or);
    this.outerRoundness.fromJSON(json.os);
    this.rotation.fromJSON(json.r);
    this.points.fromJSON(json.pt);
    this.starType = json.sy;
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      p: this.position,
      ir: this.innerRadius,
      is: this.innerRoundness,
      or: this.outerRadius,
      os: this.outerRoundness,
      r: this.rotation,
      pt: this.points,
      sy: this.starType
    };
  }
}

class RoundedCornersShape extends Shape {
  constructor() {
    super(...arguments);
    this.type = ShapeType.ROUNDED_CORNERS;
    this.roundness = new Property(this, PropertyType.NUMBER);
  }
  fromJSON(json) {
    this.classNames = json.cl;
    this.id = json.ln;
    this.isHidden = json.hd;
    this.matchName = json.mn;
    this.name = json.nm;
    this.roundness.fromJSON(json.r);
    return this;
  }
  toJSON() {
    return {
      ty: this.type,
      cl: this.classNames,
      hd: this.isHidden,
      ln: this.id,
      mn: this.matchName,
      nm: this.name,
      r: this.roundness
    };
  }
}

export { Animation, Asset, AssetType, BlendMode, EllipseShape, FillRuleType, FillShape, Gradient, GradientFillShape, GradientFillType, GradientStop, GradientStrokeShape, GradientStrokeType, GroupLayer, GroupShape, ImageAsset, ImageLayer, KeyFrame, Layer, LayerType, LineCapType, LineJoinType, Marker, Mask, MaskMode, Meta, PathShape, PrecompositionAsset, PrecompositionLayer, Property, PropertyType, RectangleShape, RepeaterComposite, RepeaterShape, RoundedCornersShape, Shape, ShapeLayer, ShapeType, SolidLayer, StarShape, StarType, StrokeShape, TextLayer, TrimMode, TrimShape, hexToRgba, rgbaToHex, useRegistry };
//# sourceMappingURL=index.esm.js.map
